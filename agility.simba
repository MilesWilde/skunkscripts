{$UNDEF SCRIPT_ID}{$DEFINE SCRIPT_ID := '62d50aa2-8708-43b3-b40e-b4406b9b1732'}
{$IFDEF WINDOWS}
{$DEFINE SCRIPT_GUI}
{$ENDIF}
{$UNDEF SCRIPT_REVISION}{$DEFINE SCRIPT_REVISION := '7'}
{$include_once SRL-T/osr.simba}
{$include_once WaspLib/osr.simba}
{$I WaspLib/osr/walker/agility.graph}

begin
  Login.PlayerIndex := 0;
end;

type
  TPlatform = record
    IsSetup: Boolean;
    Box: TBox;
    StartCoordinate: TPoint;
    EndCoordinate: TPoint;
    Obstacle: TRSObject;
    ActionText: String;
    DurationNextObstacle: Int32;
    Color: TCTS2Color;
  end;

  EAgilityState = (
    RUNNING_TO_START,
    STARTING_COURSE,
    CROSSING_OBSTACLE,
    PICKING_UP_GRACE,
    STUCK,
    UNPROCESSABLE_STATE
  );

  ECourse = (
    GNOME_AGILITY,
    VARROCK_AGILITY,
    CANIFIS_AGILITY,
    SEERS_AGILITY
  );

  TAgility = record (TBaseBankScript)
    State: EAgilityState;
    Platforms: array of TPlatform;
    CourseBoxes: TBoxArray;
    CityBox: TBox;
    CurrentPlatform: TPlatform;
    PreviousPlatform: TPlatform;
    PlatformTimer: TCountdown;
    StartAction: String;
    StartObstacle: TRSObject;
    StartCoordinate: TPoint;
    MarkOfGraceCoordinate: TPoint;
    Course: ECourse;
  end;

//const
//  SEERS_LADDER_COLOR: TCTS2Color :=

function TPlatform.Setup(box: TBox; obstacleCoord: TPoint; actionText: String; durationNextObstacle: Int32; color: TCTS2Color; height: Int32): TPlatform;
begin
  Self.IsSetup := True;
  Self.Box := box;
  Self.ActionText := actionText;
  Self.DurationNextObstacle := durationNextObstacle;
  Self.Obstacle.Setup(height, [obstacleCoord]);
  Self.Obstacle.Setup([actionText]);

  if color = [] then
    Self.Obstacle.Filter.Finder := False
  else
    Self.Obstacle.Finder.Colors += color;

  Exit(Self);
end;

function SetupPlatform(box: TBox; obstacleCoord: TPoint; actionText: String; durationNextObstacle: Int32 = 1000; color: TCTS2Color = []; height: Int32 = 1): TPlatform;
var
  platform: TPlatform;
begin
    Exit(platform.Setup(box, obstacleCoord, actionText, durationNextObstacle, color, height));
end;

function TAgility.IsStuckSeers(currentPlatform: TPlatform): Boolean;
var
  ladderTPA: TPointArray;
begin
  //SRL.FindColors(ladderTPA, SEERS_LADDER_COLOR, Mainscreen.Bounds());
  // we're upstairs
  if ladderTPA.Len() > 500 then
    Exit(True);
end;

function TAgility.IsStuck(currentPlatform: TPlatform): Boolean;
begin
  if self.PlatformTimer.IsFinished() then
    Exit(True);
  if not (self.previousPlatform = currentPlatform) then
  begin
    previousPlatform := currentPlatform;
    self.PlatformTimer.Restart();
    Exit(False);
  end;

  // we could try something like
  // if we're on seers and ladder color of the ladder nearby then we are donezo? could test a few laps with it to see if it triggers
  case self.Course of
    ECourse.SEERS_AGILITY: self.IsStuckSeers(currentPlatform);
  end;
end;

function TAgility.GetState(): EAgilityState;
var
  currentPlatform: TPlatform;
begin
  currentPlatform := Self.GetCurrentPlatform();
  if Self.IsStuck(currentPlatform) then
    Exit(EAgilityState.STUCK);
  if Self.IsMarkOfGraceOnPlatform(currentPlatform) then
    Exit(EAgilityState.PICKING_UP_GRACE);
  if Self.OnPlatform(currentPlatform) then
    Exit(EAgilityState.CROSSING_OBSTACLE);
  if Self.ReadyToStart() then
    Exit(EAgilityState.STARTING_COURSE);
  if Self.NotOnCourse() then
    Exit(EAgilityState.RUNNING_TO_START);

  Exit(EAgilityState.UNPROCESSABLE_STATE);
end;

function TAgility.IsMarkOfGraceOnPlatform(currentPlatform: TPlatform): Boolean;
var
  graceATPA: T2DPointArray;
begin
  if RSGroundItems.MarkOfGrace.Find(graceATPA) then
  begin
    WriteLn 'Spotted Mark of grace';
    if currentPlatform.Box.Contains(RSGroundItems.MarkOfGrace.ClosestDot) then
      Exit(True);

    WriteLn 'Not on our platform';
    WriteLn RSGroundItems.MarkOfGrace.ClosestDot
  end;
  Exit(False);
end;

function TAgility.NotOnCourse(): Boolean;
begin
  Exit(Self.CityBox.Contains(Self.RSW.GetMyPos()));
end;

function TAgility.ReadyToStart(): Boolean;
begin
  Exit(Self.RSW.AtTile(Self.StartCoordinate, 5));
end;

function TAgility.AtStartOfPlatform(currentPlatform: TPlatform): Boolean;
begin
  Exit(Self.RSW.AtTile(currentPlatform.StartCoordinate, 5));
end;

function TAgility.AtEndOfPlatform(currentPlatform: TPlatform): Boolean;
begin
  Exit(Self.RSW.AtTile(currentPlatform.EndCoordinate, 5));
end;

function TAgility.OnPlatform(currentPlatform: TPlatform): Boolean;
begin
  Exit(currentPlatform.IsSetup);
end;

function TAgility.GetCurrentPlatform(): TPlatform;
var
  platform: TPlatform;
begin
  for platform in Self.Platforms do
  begin
    if platform.Box.Contains(Self.RSW.GetMyPos()) then
      Exit(platform);
  end;
  WriteLn 'Not on a platform: ';
  WriteLn Self.RSW.GetMyPos();
end;

procedure TAgility.RunToStart();
begin
  Self.RSW.WalkBlind(Self.StartCoordinate, 10);
end;

procedure TAgility.RunToEndOfPlatform();
begin
  Self.RSW.WalkBlind(Self.GetCurrentPlatform().EndCoordinate, 3);
end;

function TAgility.HandleStuckSeers(): Boolean;
//var
//
begin

end;

function TAgility.HandleStuck(): Boolean;
begin
  //case self.Course of
  //  ECourse.SEERS_AGILITY:
  //end;
  WriteLn 'We are stuck';
  Logout.ClickLogout();
  TerminateScript();
end;

procedure TAgility.Setup(location: ECourse);
begin
  self.course := location;
  case location of
    ECourse.GNOME_AGILITY: Self.SetupGnome();
    ECourse.VARROCK_AGILITY: Self.SetupVarrock();
    ECourse.CANIFIS_AGILITY: Self.SetupCanifis();
    ECourse.SEERS_AGILITY: Self.SetupSeers();
  else
    raise 'Location provided not registered in cases';
  end;
end;

procedure TAgility.SetupSeers();
begin
  Self.RSW.Setup('agility', 9);
  Self.RSW.WebGraph := WaspAgility;
  Self.CityBox := [289, 994, 588, 1300];

  ItemFinder.Similarity := 0.9999;
  Self.StartCoordinate := [494, 1100];
  Self.StartAction := 'Climb-up';
  Self.Platforms := [
    SetupPlatform([797, 1107, 837, 1140], [796, 1122], 'Jump', 5000, [], 4),
    SetupPlatform([996, 1106, 1040, 1154], [1022, 1144], 'Cross', 7500, CTS2(4349291, 5, 0.10, 0.22)),
    SetupPlatform([1019, 1169, 1050, 1198], [1022, 1196], 'Jump', 4000, [], 6),
    SetupPlatform([709, 1188, 785, 1224], [722, 1225], 'Jump', 4000, [], 5),
    SetupPlatform([942, 1234, 997, 1266], [994, 1246], 'Jump', 3800)
  ];

  Self.StartObstacle.Setup(7, [[493, 1085]]);
  Self.StartObstacle.Setup([Self.StartAction]);
  Self.StartObstacle.Filter.Finder := False;
end;

procedure TAgility.SetupCanifis();
begin
  Self.RSW.Setup('agility', 9);
  Self.RSW.WebGraph := WaspAgility;
  Self.CityBox := [0, 894, 289, 1183];

  ItemFinder.Similarity := 0.9999;
  Self.StartCoordinate := [197, 1036];
  Self.StartAction := 'Climb';
  Self.Platforms := [
    SetupPlatform([740, 884, 772, 930], [750, 886], 'Jump', 5000, [], 7),
    SetupPlatform([704, 849, 743, 868], [712, 861], 'Jump', 5500, [], 5),
    SetupPlatform([660, 857, 700, 889], [665, 883], 'Jump', 4000),
    SetupPlatform([1194, 1178, 1223, 1218], [1213, 1214], 'Jump', 4000),
    SetupPlatform([631, 929, 664, 957], [646, 946], 'Pole-vault', 7500, CTS2(3037806, 6, 0.08, 0.32)),
    SetupPlatform([1230, 1262, 1318, 1310], [1313, 1275], 'Jump', 7200),
    SetupPlatform([755, 944, 791, 985], [766, 947], 'Jump', 4500)
  ];

  Self.StartObstacle.Setup(7, [[201, 1031]]);
  Self.StartObstacle.Setup([Self.StartAction]);
  Self.StartObstacle.Finder.Colors += CTS2(4283478, 12, 0.07, 0.13);
end;

procedure TAgility.SetupVarrock();
begin
  Self.RSW.Setup('agility',  9);
  ItemFinder.Similarity := 0.9999;
  Self.StartCoordinate := [208, 712];
  Self.RSW.WebGraph := WaspAgility;
  Self.CityBox := [0, 574, 360, 893];
  Self.StartAction := 'Climb';
  Self.Platforms := [
    SetupPlatform([559, 662, 595, 703], [565, 684], 'Cross', 6500),
    SetupPlatform([516, 660, 549, 690], [513, 675], 'Leap', 5500),
    SetupPlatform([844, 676, 867, 681], [840, 679], 'Balance', 10000),
    SetupPlatform([481, 713, 509, 733], [484, 736], 'Leap', 3000),
    SetupPlatform([465, 724, 549, 763], [550, 737], 'Leap', 7500),
    SetupPlatform([585, 727, 645, 771], [647, 730], 'Leap', 5500),
    SetupPlatform([655, 704, 677, 731], [658, 704], 'Hurdle', 4500),
    SetupPlatform([657, 675, 677, 702], [660, 675], 'Jump-off', 4000)
  ];

  Self.StartObstacle.Setup(7, [[208, 712]]);
  Self.StartObstacle.Setup([Self.StartAction]);
  Self.StartObstacle.Finder.Colors += CTS2(2638161, 10, 0.08, 0.33);
end;

procedure TAgility.SetupGnome();
begin
  Self.RSW.Setup('agility');
  ItemFinder.Similarity := 0.9999;
  Self.StartCoordinate := [106, 104];
  Self.RSW.WebGraph := WaspAgility;
  Self.CityBox := [82, 81, 175, 192];
  Self.StartAction := 'Walk-across';
  Self.Platforms := [
    SetupPlatform([82, 78, 173, 104], [106, 104], 'Walk-across', 12000),
    SetupPlatform([89, 125, 124, 149], [106, 144], 'Climb-over', 6500, CTS2(1654104, 21, 0.06, 2.20)),
    SetupPlatform([338, 184, 358, 192], [348, 192], 'Climb', 5500),
    SetupPlatform([332, 75, 364, 103], [362, 88], 'Walk-on', 7000, CTS2(6391459, 5, 0.06, 0.62)),
    SetupPlatform([384, 74, 419, 107], [396, 92], 'Climb-down', 3000),
    SetupPlatform([130, 140, 166, 176], [150, 140], 'Climb-over', 7500),
    SetupPlatform([130, 116, 170, 140], [146, 120], 'Squeeze-through', 9500, CTS2(5527130, 13, 0.56, 0.13))
  ];

  Self.StartObstacle.Setup(0, [[106, 104]]);
  Self.StartObstacle.Setup([Self.StartAction]);
  Self.StartObstacle.Finder.Colors += CTS2(1067632, 1, 0.17, 0.94);
end;

procedure TAntiban.SetupBreaks(); override;
begin
  if Self.Breaks <> [] then
    Exit;
  //Self.AddBreak(30 * ONE_MINUTE, 1 * ONE_MINUTE, 0.33, 0.01);
  //Self.AddBreak(45 * ONE_MINUTE, 2 * ONE_MINUTE, 0.33, 0.15);
  //Self.OnBreaking := @ OnBreakingTask;
end;

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [ERSSkill.TOTAL, ERSSkill.AGILITY];
  Self.MinZoom := 15;
  Self.MaxZoom := 25;
  inherited;
end;

procedure TAgility.Run(MaxActions: Int32; MaxTime: Int64);
var
  platform: TPlatform;
  graceATPA: T2DPointArray;
  startATPA: T2DPointArray;
begin
  Self.Init(MaxActions, MaxTime);
  repeat
    try
      Self.State := Self.GetState();
      Self.SetAction(ToStr(State));
      RSGroundItems.MarkOfGrace.Find(graceATPA);
      case State of
        EAgilityState.RUNNING_TO_START, EAgilityState.STARTING_COURSE:
          begin
            WriteLn 'Starting course';
            WriteLn Self.RSW.GetMyPos();
            TotalActions += 1;
            if Self.StartObstacle.Find(startATPA) then
              Self.StartObstacle.WalkClick(true, 1)
            else
              Self.RSW.WebWalk(Self.StartCoordinate, 50);

            Wait(7500, 8500);
          end;
        EAgilityState.CROSSING_OBSTACLE:
        begin
          WriteLn Self.RSW.GetMyPos();
          platform := Self.GetCurrentPlatform();
          platform.Obstacle.WalkClick(true, 1);
          Wait(platform.DurationNextObstacle, platform.DurationNextObstacle + 500);
        end;
        EAgilityState.PICKING_UP_GRACE:
        begin
          WriteLn 'Picking it up!';
          RSGroundItems.MarkOfGrace.Click(true, 1);
          Wait(2000, 2500);
        end;
        EAgilityState.STUCK: self.HandleStuck();
        EAgilityState.UNPROCESSABLE_STATE:
        begin
          WriteLn 'this really is unprocessable';
        end;
      end;
      Self.DoAntiban(True, False);
    except
      WriteLn GetExceptionMessage();
      Wait (5000);
    end;
  until Self.ShouldStop();
end;

procedure TAgility.Init(MaxActions: Int32; MaxTime: Int64); override;
begin
  inherited;
  RSGroundItems.Setup();
  Mouse.Speed := SRL.NormalRange(12, 21);
  Mouse.MissChance := 1;
  Self.PlatformTimer.Init(120000); // 2 minute stuck timer
  Self.Setup(ECourse.SEERS_AGILITY);
  Antiban.MaxZoom := 15;
  Antiban.MinZoom := 25;
end;

var
  Agility: TAgility;
begin
  Agility.Run(1000, 100000000);
end
